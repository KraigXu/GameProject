<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - clipping planes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="../build/three.js" type="text/javascript"></script>
		<!--<script src="js/controls/OrbitControls.js" type="text/javascript"></script>-->
		<script src="js/controls/MapControls.js" type="text/javascript"></script>
		<script src="js/libs/stats.min.js" type="text/javascript"></script>
		<script src="js/libs/dat.gui.min.js" type="text/javascript"></script>
		<script src="./jquery-2.2.1.min.js" type="text/javascript"></script>
		<!--<script src="js/decimal.min.js" type="text/javascript"></script>-->

		<script>
			var camera, scene, renderer, stats, controls;//必要元素
			var cameraX = 0, cameraY = 100, cameraZ = 0;//相机位置
			var sceneX = 0,sceneY = 0, sceneZ = 0;//视角位置
			var fov = 45, //拍摄距离  视野角值越大，场景中的物体越小
					near = 0.1,//相机离视体积最近的距离
				  far = 99999;//相机离视体积最远的距离;
			var meshdata, sharedmeshdata, circledata, transdata, materials, sharpdata//数据
			var materialDic = {};
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();
			var intersectNow, intersectColor;
			var colorlist = [[142, 199, 255], [200, 200, 255], [128, 128, 128]]
			init();
			async function init() {
				await getData();
				//init camera
				camera = new THREE.PerspectiveCamera( fov, window.innerWidth / window.innerHeight, near, far );

				//init scene
				scene = new THREE.Scene();

				//init stats
				stats = new Stats();
				document.body.appendChild( stats.dom );

				//init light
				//light = new THREE.AmbientLight(0xFFFFFF, 0.3);
				var light = new THREE.DirectionalLight(0xFFFFFF, 0.8);
				light.position.set(5000, 5000, 5000);
				var light2 = new THREE.DirectionalLight(0xFFFFFF, 0.8);
				light2.position.set(-5000, 5000, -5000);
				var light3 = new THREE.DirectionalLight(0xFFFFFF, 0.8);
				light.position.set(-5000, -5000, 5000);
				var light4 = new THREE.DirectionalLight(0xFFFFFF, 0.8);
				light2.position.set(5000, -5000, -5000);
				scene.add(light);
				scene.add(light2);
				scene.add(light3);
				//scene.add(light4);
				// initRenderer
				renderer = new THREE.WebGLRenderer({
            antialias : true
        });
				//renderer.shadowMap.enabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor(0xFFFFFF, 1.0);
				window.addEventListener( 'resize', onWindowResize, false );
				document.body.appendChild( renderer.domElement );

				// Controls
				controls = new THREE.MapControls( camera, renderer.domElement );
				controls.screenSpacePanning = true;// 若为 true 则可以平移
				controls.maxDistance = 90000;
				controls.minDistance = 1;
				//controls.maxPolarAngle = Math.PI / 2.2;

				var material = new THREE.LineBasicMaterial({
					color: 0xff0000
				});

				var geometry = new THREE.Geometry();
				geometry.vertices.push(
					new THREE.Vector3(-10000, 0, 0),
					new THREE.Vector3(0, 0, 0)
				);

				var line = new THREE.Line(geometry, material);
				scene.add(line);

				var material = new THREE.LineBasicMaterial({
					color: 0x000000
				});

				var geometry = new THREE.Geometry();
				geometry.vertices.push(
					new THREE.Vector3(0, 0, 0),
					new THREE.Vector3(10000, 0, 0)
				);

				var line = new THREE.Line(geometry, material);
				scene.add(line);

				var material = new THREE.LineBasicMaterial({
					color: 0x0000ff
				});

				var geometry = new THREE.Geometry();
				geometry.vertices.push(
					new THREE.Vector3(0, -10000, 0),
					new THREE.Vector3(0, 0, 0)
				);

				var line = new THREE.Line(geometry, material);
				scene.add(line);
				var material = new THREE.LineBasicMaterial({
					color: 0xffff00
				});

				var geometry = new THREE.Geometry();
				geometry.vertices.push(
					new THREE.Vector3(0, 0, 0),
					new THREE.Vector3(0, 10000, 0)
				);

				var line = new THREE.Line(geometry, material);
				scene.add(line);
				var material = new THREE.LineBasicMaterial({
					color: 0x00ff00
				});

				var geometry = new THREE.Geometry();
				geometry.vertices.push(
					new THREE.Vector3(0, 0, -10000),
					new THREE.Vector3(0, 0, 10000)
				);

				var line = new THREE.Line(geometry, material);
				scene.add(line);

				if (meshdata != undefined) {
					$.each(meshdata.rows, function (i, ele) {
						initModel(ele[0], ele[1], ele[2], ele[3], ele[4], false);
					})
				}
				if (sharedmeshdata != undefined) {
					$.each(sharedmeshdata.rows, function (i, ele) {
						initModel(ele[0], ele[1], ele[2], ele[3], ele[4], true);
					})
				}
				if (circledata != undefined) {
					$.each(circledata.rows, function (i, ele) {
						initModel2(ele[0], ele[1], ele[2], ele[3]);
					})
				}
				if (sharpdata != undefined) {
					$.each(sharpdata, function (i, ele) {
						initModel3(ele);
					})
				}

				renderInit();
				window.addEventListener('mousedown', onMousDown, false);
				window.addEventListener('mouseup', onMousUp, false);

				animate();
			}

			async function getData(){
				//await getmesh();
				//await getshardmesh();
				//await gettrans();
				//await getcircle();
				//await getmaterial();
				await getwall();
				return;
			}

			async function getwall() {
				return new Promise(function (resolve, reject) {
					$.ajax({
						type: "get",
						url: "./datas/walltest.json",
						dataType: 'json',
						success: function (data) {
							sharpdata = data;
							resolve("sharpComplete");
						}
					});
				})
			}

			async function getmesh() {
				return new Promise(function (resolve, reject) {
					$.ajax({
						type: "get",
						url: "./datas/mesh_5.json",
						dataType: 'json',
						success: function (data) {
							meshdata = data;
							resolve("meshComplete");
						}
					});
				})
			}

			async function getshardmesh() {
				return new Promise(function (resolve, reject) {
					$.ajax({
						type: "get",
						url: "./datas/shared_mesh_5.json",
						dataType: 'json',
						success: function (data) {
							sharedmeshdata = data;
							resolve("shardmeshComplete");
						}
					});
				})
			}

			async function getcircle() {
				return new Promise(function (resolve, reject) {
					$.ajax({
						type: "get",
						url: "./datas/circle_5.json",
						dataType: 'json',
						success: function (data) {
							circledata = data;
							resolve("circleComplete");
						}
					});
				})
			}

			async function gettrans() {
				return new Promise(function (resolve, reject) {
					$.ajax({
						type: "get",
						url: "./datas/transform_5.json",
						dataType: 'json',
						success: function (data) {
							transdata = data;
							resolve("transComplete");
						}
					});
				})
			}

			async function getmaterial() {
				return new Promise(function (resolve, reject) {
					$.ajax({
						type: "get",
						url: "./datas/material_5.json",
						dataType: 'json',
						success: function (data) {
							materials = data;
							resolve("materialsComplete");
						}
					});
				})
			}

			function getmetrial(id, flg, geometry, uvs){
				let material;
				if (materials != undefined) {
					for (var i = 0; i < materials.length; i++) {
						if (materials[i].ElementIds.indexOf(id) >= 0) {
							if (materialDic[materials[i].MaterialId + ""] != null) {
								if (materials[i].MapInfo != undefined && materials[i].MapInfo[0] != -1 && flg) {
									assignUVs(geometry, uvs);
								}
								return materialDic[materials[i].MaterialId].clone();
							}
							else {
								if (materials[i].MapInfo != undefined && materials[i].MapInfo[0] != -1) {
									var texture = new THREE.TextureLoader().load("datas/" + materials[i].MapInfo[0].split("|")[0]);
									texture.wrapS = THREE.RepeatWrapping;
									texture.wrapT = THREE.RepeatWrapping;
									if (flg) {
										assignUVs(geometry, uvs);
									}
									material = new THREE.MeshPhongMaterial({
										color: new THREE.Color("rgb(" + materials[i].Color.join(",") + ")"),
										shininess: 100,
										side: THREE.DoubleSide,
										transparent: true,
										map: texture
									});
								}
								else {
									material = new THREE.MeshPhongMaterial({
										color: new THREE.Color("rgb(" + materials[i].Color.join(",") + ")"),
										shininess: 100,
										side: THREE.DoubleSide,
										transparent: true
									});
								}
								materialDic[materials[i].MaterialId + ""] = material;
								return material;
							}
						}
					}
				}
				if(material == undefined){
					return new THREE.MeshPhongMaterial({
							color: 0x000000,
							shininess: 100,
							side: THREE.DoubleSide,
							transparent: true
						});
				}
			}

			function onMousDown(event) {

				//通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

				// 通过鼠标点的位置和当前相机的矩阵计算出raycaster
				raycaster.setFromCamera(mouse, camera);

				// 获取raycaster直线和所有模型相交的数组集合
				var intersects = raycaster.intersectObjects(scene.children);
				if (intersects.length > 0) {
					intersectBefuuid = intersects[0].object.uuid;
				}
				else {
					intersectBefuuid = "";
				}
			}

			function onMousUp(event) {

				//通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

				// 通过鼠标点的位置和当前相机的矩阵计算出raycaster
				raycaster.setFromCamera(mouse, camera);

				// 获取raycaster直线和所有模型相交的数组集合
				var intersects = raycaster.intersectObjects(scene.children);

				if (intersects.length == 0 && intersectNow == null) {
					return;
				}

				if (intersects.length == 0 && intersectNow != null) {
					intersectNow.object.material.color.set(intersectColor);
					intersectNow.object.material.opacity = 1;
					intersectNow = null;
					intersectColor = null;
					return;
				}
				if (intersects.length > 0 && intersectNow != null) {
					intersectNow.object.material.color.set(intersectColor);
					intersectNow.object.material.opacity = 1;
					intersectNow = intersects[0];
					intersectColor = intersectNow.object.material.color.clone();
					intersectNow.object.material.color.set(0x0000ff);
					intersectNow.object.material.opacity = 0.6;
					console.log(intersects[0]);
					console.log(intersects[0].object.name);
					return;
				}
				if (intersects.length > 0 && intersectNow == null) {
					intersectNow = intersects[0];
					intersectColor = intersectNow.object.material.color.clone();
					intersectNow.object.material.color.set(0x0000ff);
					intersectNow.object.material.opacity = 0.6;
					console.log(intersects[0]);
					console.log(intersects[0].object.name);
					return;
				}
			}

			function getShapes(shapes,holes) {
				var shape = new THREE.Shape();
				//let Xall = 0;
				//let Yall = 0;
				//for (var i = 1; i < shapes.length; i += 2) {
				//	Xall += shapes[i];
				//	Yall += shapes[i+1];
				//}
				//Xcor = Xall / ((shapes.length - 1) / 2);
				//Ycor = Yall / ((shapes.length - 1) / 2);
				if (shapes[0] == 1) {
					for (var i = 1; i < shapes.length; i += 2) {
						if (i == 1) {
							//shape.moveTo(shapes[i], 1 * shapes[i + 1]);
							//shape.moveTo(shapes[i] - Xcor, shapes[i + 1] - Ycor);
							shape.moveTo(0, 0);
						}
						else {
							//shape.lineTo(shapes[i] - Xcor, shapes[i + 1] - Ycor);
							shape.lineTo(shapes[i] - shapes[1], shapes[i+1] - shapes[2]);
						}
					}
				}
				//if (holes != []){
				//	$.each(holes, function (i, hole) {
				//		var holeNow = new THREE.Path();
				//		for (var i = 1; i < hole.length; i += 2) {
				//			if (i == 1) {
				//				holeNow.moveTo(hole[i] - Xcor, hole[i + 1] - Ycor);
				//			}
				//			else {
				//				holeNow.lineTo(hole[i] - Xcor, hole[i + 1] - Ycor);
				//			}
				//		}
				//		shape.holes.push(holeNow);
				//	});
				//}
				return shape;
			}

			function initModel3(ele) {
				//if (ele[1][0][0][1][0] != 1) {
				//	return;
				//}
				var shapes = getShapes(ele[2], ele[3]);


				var curvePath = new THREE.CatmullRomCurve3([new THREE.Vector3(ele[1][0], ele[1][1], ele[1][2]), new THREE.Vector3(ele[1][3], ele[1][4], ele[1][5])]);
				var options = {
					//depth: 2,
					bevelEnabled: false,
					steps:20,
					extrudePath: curvePath
				}

				var geometry = new THREE.ExtrudeGeometry(shapes, options);
				geometry.computeBoundingSphere();
				//let materialNew = getmetrial(ele[0], false, geometry, null);
				let materialNew = new THREE.MeshPhongMaterial({
					color: new THREE.Color("rgb(" + colorlist[ele[0][1]][0] + "," + colorlist[ele[0][1]][1] + "," + colorlist[ele[0][1]][2] + ")"),
					shininess: 100,
					side: THREE.DoubleSide,
					transparent: true
				});
				var object = new THREE.Mesh(geometry, materialNew);
				object.name = ele[0][0];
				//object.matrixAutoUpdate = false;
				//let mat42 = new THREE.Matrix4();
				//mat42.set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
				//object.matrix.multiply(mat42);
				scene.add(object);
			}

			function initModel2(r,l,ids,positions,transFlg) {
				var object;
				positions = relizePos(positions);
				var geometry = new THREE.CylinderGeometry(r/2,r/2,l,64);
				geometry.computeBoundingSphere();
				for (var i = 0; i < ids.length; i++) {
					let materialNew = getmetrial(ids[i], false, geometry,null);
					object = new THREE.Mesh(geometry, materialNew);
					object.matrixAutoUpdate = false;
					let mat42 = new THREE.Matrix4();
					mat42.set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
					object.matrix.multiply(mat42);
					var op = new THREE.Quaternion();
					op.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(positions[i][4], positions[i][5], positions[i][6] ));
					object.matrix.makeRotationFromQuaternion(op).setPosition(new THREE.Vector3(positions[i][0], positions[i][2], -positions[i][1]));
					scene.add(object);
				}
			}

			function initModel(id,points,facets,uvs,normals,transFlg) {
				var object;
				normals = relizeNormals(normals);
				points = relizePoints(points);
				facets = relizeFacets(facets);
				uvs = relizeUvs(uvs);
				var geometry = new THREE.Geometry();
				geometry.uvsNeedUpdate = true;
				geometry.elementsNeedUpdate = true;
				geometry.normalsNeedUpdate = true;
				$.each(points, function (i, ele) {
					geometry.vertices.push(new THREE.Vector3(ele[0], ele[1], ele[2]));
				});
				$.each(facets, function (i, ele) {
					geometry.faces.push(new THREE.Face3(ele[0], ele[1], ele[2], new THREE.Vector3(normals[ele[0]][0], normals[ele[0]][1] ,normals[ele[0]][2])));
				});
				geometry.computeBoundingSphere();
				geometry.computeBoundingBox(); 
				geometry.name = id;

				object = new THREE.Mesh(geometry);
				object.matrixAutoUpdate = false;
				let mat4 = new THREE.Matrix4();
				mat4.set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
				object.matrix.multiply(mat4);
				if(transFlg){
					for (var i = 0; i < transdata.rows.length; i++) {
						if (transdata.rows[i][0] == id) {
							let objectNew = object.clone();
							objectNew.matrixAutoUpdate = false;
							objectNew.name = transdata.rows[i][1];
							let mat42 = new THREE.Matrix4();
							mat42.set(transdata.rows[i][2][0],transdata.rows[i][2][3],transdata.rows[i][2][6],0,transdata.rows[i][2][1],transdata.rows[i][2][4],transdata.rows[i][2][7],0,transdata.rows[i][2][2],transdata.rows[i][2][5],transdata.rows[i][2][8],0,0,0,0,1);
							objectNew.matrix.multiply(mat42).setPosition(new THREE.Vector3(transdata.rows[i][2][9], transdata.rows[i][2][11], -transdata.rows[i][2][10]));
							let materialNew = getmetrial(transdata.rows[i][1], true, geometry,uvs);
							objectNew.material = materialNew;
							scene.add(objectNew);
						}
					};
				}
				else {
					let materialNew = getmetrial(id, true, geometry, uvs);
					object.material = materialNew;
					object.name = id;
					scene.add(object);
				}
			}

			function assignUVs(geometry, uvs) {
				var maxU, minU, maxV, minV, lenU, lenV;
				$.each(uvs, function (i, ele) {
					if (maxU == null || (maxU != null && maxU < ele[0])) {
						maxU = ele[0]
					}
					if (minU == null || (minU != null && minU > ele[0])) {
						minU = ele[0]
					}
					if (maxV == null || (maxV != null && maxV < ele[1])) {
						maxV = ele[1]
					}
					if (minV == null || (minV != null && minV > ele[1])) {
						minV = ele[1]
					}
				})
				lenU = maxU - minU;
				lenV = maxV - minV;
				
				var faces = geometry.faces;
				geometry.faceVertexUvs[0] = [];
				for (var i = 0; i < faces.length; i++) {
					//geometry.faceVertexUvs[0].push([
					//	new THREE.Vector2((uvs[faces[i].a][0] - minU) / lenU, (uvs[faces[i].a][1] - minV) / lenV),
					//	new THREE.Vector2((uvs[faces[i].b][0] - minU) / lenU, (uvs[faces[i].b][1] - minV) / lenV),
					//	new THREE.Vector2((uvs[faces[i].c][0] - minU) / lenU, (uvs[faces[i].c][1] - minV) / lenV)
					//]);
					//geometry.faceVertexUvs[0].push([
					//	new THREE.Vector2((uvs[faces[i].a][1] - minV) / lenV,(uvs[faces[i].a][0] - minU) / lenU ),
					//	new THREE.Vector2((uvs[faces[i].b][1] - minV) / lenV,(uvs[faces[i].b][0] - minU) / lenU ),
					//	new THREE.Vector2((uvs[faces[i].c][1] - minV) / lenV,(uvs[faces[i].c][0] - minU) / lenU )
					//]);
					//geometry.faceVertexUvs[0].push([
					//	new THREE.Vector2(uvs[faces[i].a][1] / 46 * 5, uvs[faces[i].a][0] / 46 * 5),
					//	new THREE.Vector2(uvs[faces[i].b][1] / 46 * 5, uvs[faces[i].b][0] / 46 * 5),
					//	new THREE.Vector2(uvs[faces[i].c][1] / 46 * 5, uvs[faces[i].c][0] / 46 * 5)
					//]);
					geometry.faceVertexUvs[0].push([
						new THREE.Vector2(uvs[faces[i].a][1] / 2, uvs[faces[i].a][0] / 2),
						new THREE.Vector2(uvs[faces[i].b][1] / 2, uvs[faces[i].b][0] / 2),
						new THREE.Vector2(uvs[faces[i].c][1] / 2, uvs[faces[i].c][0] / 2)
					]);
				}
			}

			function changePivot(x,y,z,obj){
				 let wrapper = new THREE.Object3D();
							wrapper.position.set(x,y,z);
							wrapper.add(obj);
							obj.position.set(-x,-y,-z);
							return wrapper;
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				controls.update();
				requestAnimationFrame( animate );
				stats.begin();
				renderer.render( scene, camera );
				stats.end();
			}

			function relizePos(pos){
				var poslater = [];
				for(var i=0;i<pos.length;i+=6){
					poslater.push(pos.slice(i,i+6));
				};
				return poslater;
			}

			function relizePoints(points){
				var pointslater = [];
				for(var i=0;i<points.length;i+=3){
					pointslater.push(points.slice(i,i+3));
				};
				return pointslater;
			}

			function relizeFacets(facets){
				var facetslater = [];
				for(var i=0;i<facets.length;i+=3){
					facetslater.push(facets.slice(i,i+3));
				};
				return facetslater;
			}

			function relizeUvs(uvs){
				var uvslater = [];
				for(var i=0;i<uvs.length;i+=2){
					uvslater.push(uvs.slice(i,i+2));
				};
				return uvslater;
			}

			function relizeNormals(normals){
				var normallater = [];
				for(var i=0;i<normals.length;i+=4){
					var count = normals[i];
					for(var o=0;o<count;o++){
						var newArray = [normals[i+1],normals[i+2],normals[i+3]];
						normallater.push(newArray);
					}
				};
				return normallater;
			}

			function renderInit(){
				camera.position.set(cameraX, cameraY, cameraZ);
				camera.lookAt(sceneX, sceneY, sceneZ);
				camera.updateProjectionMatrix();
				renderer.render(scene, camera);
			}


		</script>

	</body>
</html>
