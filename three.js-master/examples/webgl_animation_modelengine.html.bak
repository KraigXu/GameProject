<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - cloth simulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
        color: #000;
        font-family:Monospace;
        font-size:13px;
        text-align:center;
        font-weight: bold;

        background-color: #fff;
        margin: 0px;
        overflow: hidden;
			}
			a {
				color: #080;
			}

		</style>
	</head>

	<body>
		<div id="container"></div>
		<div id="info">Simple Cloth Simulation<br/>
			Verlet integration with relaxed constraints<br/>
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			let camera, controls, scene, renderer;
		
			var container, stats;
    //模型包围盒
    var modelBox3 = new THREE.Box3();

    var meshBox3 = new THREE.Box3();

		var mesh, texture;
	
		var raycaster = new THREE.Raycaster();
		var mouse = new THREE.Vector2();
		var helper;
		
    init();
    //render(); // remove when using next line for animation loop (requestAnimationFrame)
    animate();

    function init() {

				container = document.getElementById( 'container' );
				container.innerHTML = "";
				container.addEventListener( 'mousemove', onMouseMove, false );
				
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xcccccc );
        //scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );
      //  document.body.appendChild( renderer.domElement );

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000000 );
        camera.position.set( -112417.55771430256, 64121.59264444466, 23940.856823256017 );
        camera.rotation.set( -1.2178822080031084, -0.9004236436148543, -1.1313862615404136 );

        // controls

        controls = new THREE.OrbitControls( camera, renderer.domElement );

        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.25;

        controls.screenSpacePanning = false;

        controls.maxPolarAngle = Math.PI / 2;

        window.addEventListener( 'resize', onWindowResize, false );
        
        
        var geometry = new THREE.PlaneBufferGeometry( 7500, 7500, worldWidth - 1, worldDepth - 1 );
				geometry.rotateX( - Math.PI / 2 );

				var vertices = geometry.attributes.position.array;

				for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {

					vertices[ j + 1 ] = data[ i ] * 10;

				}

				geometry.computeFaceNormals(); // needed for helper
        
        
        
        
        stats = new Stats();
				container.appendChild( stats.dom );
        

        hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
        hemiLight.color.setHSL( 0.6, 1, 0.6 );
        hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
        hemiLight.position.set( 0, 50, 0 );
        scene.add( hemiLight );

        var ambient = new THREE.AmbientLight(0x9a9a9a );
        scene.add(ambient);

        var light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
        light.position.set( 1, 0.5, 0.8 );

        hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
        scene.add( hemiLightHelper );
        
       	texture = new THREE.CanvasTexture( generateTexture( data, worldWidth, worldDepth ) );
				texture.wrapS = THREE.ClampToEdgeWrapping;
				texture.wrapT = THREE.ClampToEdgeWrapping;

				mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );
				scene.add( mesh );
        

        var loader = new THREE.ObjectLoader();

        loader.load("../model/rac_advanced_sample_project.rvt.json",
            function ( obj ) {
                scene.add( obj );

                //获取模型的包围盒
                modelBox3.expandByObject(obj);

                //计算模型的中心点坐标，这个为爆炸中心
                var modelWorldPs = new THREE.Vector3().addVectors(modelBox3.max, modelBox3.min).multiplyScalar(0.5);

                obj.traverse(function (value) {
                    if(value.isMesh){
                        meshBox3.setFromObject(value);

                        //获取每个mesh的中心点，爆炸方向为爆炸中心点指向mesh中心点
                        var worldPs = new THREE.Vector3().addVectors(meshBox3.max, meshBox3.min).multiplyScalar(0.5);
                        if(isNaN(worldPs.x))return;
                        //计算爆炸方向
                        value.worldDir = new THREE.Vector3().subVectors(worldPs, modelWorldPs).normalize();
                        //保存初始坐标
                        value.userData.oldPs = value.getWorldPosition(new THREE.Vector3())
                    }
                });

                function applyScalar(scalar){

                    obj.traverse(function (value) {
                        if(!value.isMesh || !value.worldDir) return;

                        //爆炸公式
                        value.position.copy(new THREE.Vector3().copy(value.userData.oldPs).add(new THREE.Vector3().copy(value.worldDir).multiplyScalar(scalar)))
                    });

                }

                document.querySelector("#myRange").addEventListener('input', function (evt) {
                    applyScalar(this.value * 500)
                })
            }
        );
        var axesHelper = new THREE.AxesHelper( 500000 );
        scene.add( axesHelper );
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function onMouseMove( event ) {
				console.log('input mouse');
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				
				raycaster.setFromCamera( mouse, camera );

				console.log(mesh);
				// See if the ray from the camera into the world hits one of our meshes
				var intersects = raycaster.intersectObject( mesh );

				// Toggle rotation bool for meshes that we clicked
				if ( intersects.length > 0 ) {

					helper.position.set( 0, 0, 0 );
					helper.lookAt( intersects[ 0 ].face.normal );

					helper.position.copy( intersects[ 0 ].point );

				}
		}
    

    function animate() {
        requestAnimationFrame( animate );
        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
        render();
    }

    function render() {
        renderer.render( scene, camera );
    }			
		</script>
	</body>
</html>
